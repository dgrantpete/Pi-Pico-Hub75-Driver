from typing import Final, Iterable, Literal, overload, Set, TypeVar

# ----- PIO TypeVars -----
T = TypeVar("T")

# ----- PIO Core Instruction Types -----
class PIODelayableInstruction:
    def __getitem__(self, delay: int): ...

class PIOInstruction(PIODelayableInstruction):
    def side(self, value: int) -> PIODelayableInstruction: ...

# ----- PIO Type Categories -----
class PIOMoveOperable: ...
class PIOMoveOperated: ...
class PIOMoveTarget: ...
class PIOInSource: ...
class PIOOutTarget: ...
class PIOSetTarget: ...
class PIOJumpCondition: ...
class PIOWaitSource: ...
class PIOPushPullModifier: ...
class PIOIRQModifier: ...

PIOMoveSource = PIOMoveOperable | PIOMoveOperated
PIOJumpTarget = int | str

# ----- PIO Register/Pin Classes -----
class PIORegister(PIOMoveOperable, PIOMoveTarget, PIOOutTarget, PIOInSource, PIOSetTarget): ...

class PIOPins(PIOMoveOperable, PIOMoveTarget, PIOOutTarget, PIOInSource, PIOSetTarget): ...

class PIOPinDirs(PIOOutTarget, PIOSetTarget): ...

class PIOProgramCounter(PIOMoveTarget, PIOOutTarget): ...

class PIOInputShiftRegister(PIOOutTarget, PIOMoveOperable, PIOInSource, PIOMoveTarget): ...

class PIOOutputShiftRegister(PIOMoveOperable, PIOInSource, PIOMoveTarget): ...

class PIONull(PIOMoveOperable, PIOMoveTarget, PIOInSource, PIOOutTarget):
    """Note: MOV dest 3 is 'Reserved' in hardware, but MicroPython allows it."""
    ...

class PIOStatus(PIOMoveOperable): ...

class PIOExec(PIOMoveTarget, PIOOutTarget): ...

class PIOGpio(PIOWaitSource): ...

class PIOPin(PIOJumpCondition, PIOWaitSource): ...

class PIOIRQ(PIOWaitSource):
    def __call__(self, *args) -> PIOInstruction: ...

# ----- PIO Register/Pin Instances -----
x: Final[PIORegister]
y: Final[PIORegister]
pins: Final[PIOPins]
pindirs: Final[PIOPinDirs]
pc: Final[PIOProgramCounter]
isr: Final[PIOInputShiftRegister]
osr: Final[PIOOutputShiftRegister]
null: Final[PIONull]
status: Final[PIOStatus]
exec: Final[PIOExec]
gpio: Final[PIOGpio]
pin: Final[PIOPin]
irq: Final[PIOIRQ]

# ----- PIO Jump Conditions -----
x_dec: Final[PIOJumpCondition]
y_dec: Final[PIOJumpCondition]
not_x: Final[PIOJumpCondition]
not_y: Final[PIOJumpCondition]
x_not_y: Final[PIOJumpCondition]
not_osre: Final[PIOJumpCondition]

# ----- PIO Push/Pull Modifiers -----
iffull: Final[PIOPushPullModifier]
ifempty: Final[PIOPushPullModifier]
block: Final[PIOPushPullModifier]
noblock: Final[PIOPushPullModifier]

# ----- PIO IRQ Modifiers -----
clear: Final[PIOIRQModifier]

# ----- PIO MOV Operations -----
def invert(to_invert: PIOMoveOperable) -> PIOMoveOperated: ...
def reverse(to_reverse: PIOMoveOperable) -> PIOMoveOperated: ...

# ----- PIO IRQ Modifier Function -----
def rel(irq_index: int) -> int: ...

# ----- PIO Instructions -----
def wrap() -> None: ...

def wrap_target() -> None: ...

def nop() -> PIOInstruction: ...

def mov(destination: PIOMoveTarget, source: PIOMoveSource) -> PIOInstruction: ...

def in_(source: PIOInSource, bit_count: int) -> PIOInstruction: ...

@overload
def jmp(target: PIOJumpTarget) -> PIOInstruction: ...
@overload
def jmp(condition: PIOJumpCondition, target: PIOJumpTarget) -> PIOInstruction: ...

def wait(polarity: Literal[1] | Literal[0], source: PIOWaitSource, index: int) -> PIOInstruction: ...

def out(target: PIOOutTarget, bit_count: int) -> PIOInstruction: ...

def label(label: str) -> None: ...

@overload
def set(dest: PIOSetTarget, value: int) -> PIOInstruction: ...
@overload
def set() -> Set: ...
@overload
def set(iterable: Iterable[T]) -> Set[T]: ...

@overload
def push() -> PIOInstruction: ...
@overload
def push(modifier: PIOPushPullModifier) -> PIOInstruction: ...
@overload
def push(modifier1: PIOPushPullModifier, modifier2: PIOPushPullModifier) -> PIOInstruction: ...

@overload
def pull() -> PIOInstruction: ...
@overload
def pull(modifier: PIOPushPullModifier) -> PIOInstruction: ...
@overload
def pull(modifier1: PIOPushPullModifier, modifier2: PIOPushPullModifier) -> PIOInstruction: ...

@overload
def word(instr: int) -> PIOInstruction: ...
@overload
def word(instr: int, label: str) -> PIOInstruction: ...